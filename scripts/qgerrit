#!/usr/bin/env python

# -*- coding: utf-8 -*-

# vim: tabstop=4 shiftwidth=4 softtabstop=4

#    Copyright (C) 2013 Yahoo! Inc. All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import json
import optparse
import os
import subprocess

from datetime import datetime

import prettytable

GERRIT_HOST = 'review.openstack.org'
GERRIT_PORT = 29418
GERRIT_CMD = ('gerrit', 'query', '--format=JSON')
TRUNCATE_LEN = 27


def tiny_p(cmd, capture=True):
    # Borrowed from cloud-init...
    #
    # Darn python 2.6 doesn't have check_output (argggg)
    stdout = subprocess.PIPE
    stderr = subprocess.PIPE
    if not capture:
        stdout = None
        stderr = None
    sp = subprocess.Popen(cmd, stdout=stdout,
                          stderr=stderr, stdin=None)
    (out, err) = sp.communicate()
    ret = sp.returncode  # pylint: disable=E1101
    if ret not in [0]:
        raise RuntimeError("Failed running %s [rc=%s] (%s, %s)"
                           % (cmd, ret, out, err))
    return (out, err)


def run_query(loginname, query, keyfile):
    cmd = ['ssh']
    if keyfile and os.path.isfile(keyfile):
        cmd.extend(['-i', str(keyfile)])
    if loginname is not None:
        BASE_CMD_OPTS = (loginname+'@'+GERRIT_HOST, '-p', str(GERRIT_PORT))
    else:
        BASE_CMD_OPTS = (GERRIT_HOST, '-p', str(GERRIT_PORT))
    cmd.extend(BASE_CMD_OPTS)
    cmd.extend(GERRIT_CMD)
    cmd.append(query)
    (stdout, _stderr) = tiny_p(cmd)
    entries = stdout.splitlines()
    results = []
    for e in entries:
        dec = json.loads(e)
        if 'rowCount' in dec:
            continue
        results.append(dec)
    return results


def _get_key(k, row, truncate=False):
    if k not in row:
        return ""
    v = str(row[k])
    if truncate:
        if len(v) > TRUNCATE_LEN:
            v = v[0:TRUNCATE_LEN] + "..."
    return v


def print_wrapped(text):
    print("-" * (len(text)))
    print(text)
    print("-" * (len(text)))


def _get_date(k, row):
    v = _get_key(k, row)
    if not v:
        return ''
    try:
        dt = datetime.fromtimestamp(int(v))
        return dt.strftime('%I:%M %p %m/%d/%y')
    except (TypeError, ValueError):
        return ''

def print_results(results):
    headers = ["Status", "Topic", "Url", "Project", 'Subject',
               'Created On', 'Last Updated']
    table = prettytable.PrettyTable(headers)
    table.padding_width = 1
    num_seen = set()
    for res in results:
        try:
            num = int(res['number'])
        except (ValueError, TypeError, KeyError):
            num = -1
        if num < 0:
            continue
        if num in num_seen:
            continue

        num_seen.add(num)

        row = [
            _get_key('status', res), _get_key('topic', res, truncate=True),
            _get_key('url', res), _get_key('project', res),
            _get_key('subject', res, truncate=True),
            _get_date('createdOn', res), _get_date('lastUpdated', res),
        ]
        table.add_row(row)

    if len(num_seen):
        print(table.get_string(sortby="Status"))


def get_info(loginname, keyfile, terms):
    clauses = []
    for term in terms:
        if len(terms[term]) == 0:
            continue

        clause = " OR ".join(map(lambda value: "%s:%s" % (term, value), terms[term]))
        if clause != "":
            clauses.append(clause)
    query = " AND ".join(map(lambda clause: "(%s)" % clause, clauses))
    return run_query(loginname, query, keyfile)

def _get_key_path():
    home_dir = os.path.expanduser("~")
    ssh_dir = os.path.join(home_dir, ".ssh")
    if not os.path.isdir(ssh_dir):
        return None
    for k in ('id_rsa', 'id_dsa'):
        path = os.path.join(ssh_dir, k)
        if os.path.isfile(path):
            return path
    return None


def main():
    parser = optparse.OptionParser()
    parser.add_option("-l", "--login", dest="login", action='store',
                      help="connect to gerrit with USER", metavar="USER")
    parser.add_option("-u", "--user", dest="users", action='append',
                      help="gather information on given USER", metavar="USER",
                      default=[])
    parser.add_option("-k", "--keyfile", dest="keyfile", action='store',
                      help="gerrit ssh keyfile [default: %default]",
                      metavar="FILE", default=_get_key_path())
    (options, args) = parser.parse_args()
    entries = get_info(options.login,
                       options.keyfile,
                       { "owner": list(options.users),
                         "status": ["open"] })
    print_results(entries)


if __name__ == '__main__':
    main()
